<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Global Energy System Performance Map</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        rel="stylesheet"
        href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""
    />
    <script
        src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""
    ></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        #map {
            height: 75vh;
        }
        .leaflet-popup-content-wrapper {
            background-color: #1f2937;
            color: #f3f4f6;
            border-radius: 0.5rem;
        }
        .leaflet-popup-tip {
            background: #1f2937;
        }
        .leaflet-popup-content {
            margin: 12px 18px;
        }
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4b5563;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        .legend {
            padding: 10px 12px;
            font-family: sans-serif;
            background: rgba(31, 41, 55, 0.85);
            color: #f3f4f6;
            border-radius: 5px;
            line-height: 20px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            width: 220px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
        }
        .voronoi-cell {
            stroke: rgba(255, 255, 255, 0.08);
            stroke-width: 0.5;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">
    <div class="container mx-auto p-4 md:p-6">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-white">Global Energy System Performance</h1>
            <p class="text-gray-400 mt-2">
                Visualize system capacity factor by mix or by an LCOE threshold. Upload a CSV exported from
                <code>baseload.dashboard_data</code> or load the sample dataset bundled with this repository.
            </p>
        </header>
        <div id="controls" class="bg-gray-800 p-6 rounded-lg shadow-lg mb-6">
            <div id="upload-section" class="space-y-3">
                <label for="csv-file" class="block text-lg font-medium text-white">1. Upload your LCOE file</label>
                <input
                    type="file"
                    id="csv-file"
                    accept=".csv"
                    class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600 cursor-pointer"
                />
                <button
                    id="load-sample"
                    class="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-md text-white text-sm font-semibold"
                    type="button"
                >
                    Load bundled sample data
                </button>
                <p id="status-message" class="text-gray-500 text-sm">
                    Please upload your CSV. Need an example? Click "Load bundled sample data".
                </p>
            </div>
            <div id="sliders-section" class="mt-6 hidden">
                <h2 class="text-lg font-medium text-white mb-4">2. Select Visualization Mode</h2>
                <div class="flex flex-col md:flex-row md:items-center md:space-x-6 space-y-3 md:space-y-0 mb-4 border-b border-gray-700 pb-4">
                    <label class="inline-flex items-center">
                        <input
                            type="radio"
                            id="mode-mix"
                            name="vis-mode"
                            value="mix"
                            checked
                            class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"
                        />
                        <span class="ml-2">By system mix</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input
                            type="radio"
                            id="mode-lcoe"
                            name="vis-mode"
                            value="lcoe"
                            class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500"
                        />
                        <span class="ml-2">By max LCOE</span>
                    </label>
                </div>
                <div id="mix-sliders-section" class="space-y-6">
                    <p class="text-sm text-gray-400">
                        The current simulation sweep only varies solar and battery capacity, so the wind slider will snap to the
                        closest available value (0&nbsp;GW in the bundled data).
                    </p>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div>
                            <label for="solar-slider" class="block mb-2 font-medium">
                                Solar capacity: <span id="solar-value" class="font-bold text-blue-400">1 GW</span>
                            </label>
                            <input type="range" id="solar-slider" min="1" max="8" value="1" class="w-full" />
                        </div>
                        <div>
                            <label for="wind-slider" class="block mb-2 font-medium">
                                Wind capacity: <span id="wind-value" class="font-bold text-blue-400">0 GW</span>
                            </label>
                            <input type="range" id="wind-slider" min="0" max="4" value="0" class="w-full" />
                        </div>
                        <div>
                            <label for="battery-slider" class="block mb-2 font-medium">
                                Battery capacity: <span id="battery-value" class="font-bold text-blue-400">1 GWh</span>
                            </label>
                            <input type="range" id="battery-slider" min="1" max="15" value="1" class="w-full" />
                        </div>
                    </div>
                </div>
                <div id="lcoe-slider-section" class="hidden">
                    <label for="lcoe-slider" class="block mb-2 font-medium">
                        Max LCOE: <span id="lcoe-value" class="font-bold text-blue-400">$100 / MWh</span>
                    </label>
                    <input type="range" id="lcoe-slider" min="20" max="400" value="100" class="w-full" />
                </div>
            </div>
        </div>
        <div id="map-container" class="bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            <div id="map"></div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            let map;
            let dispatchData = [];
            let availableWindLevels = new Set();
            const circlesLayer = L.layerGroup();
            const voronoiLayer = L.svg();
            let legend;
            let worldGeoJSON;

            try {
                const response = await fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson');
                worldGeoJSON = await response.json();
            } catch (e) {
                console.error('Could not load world GeoJSON data:', e);
                document.getElementById('status-message').textContent = 'Error: Could not load map landmass data. Please refresh.';
                return;
            }

            map = L.map('map').setView([20, 0], 2);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19,
            }).addTo(map);
            map.getPane('tilePane').style.zIndex = 200;
            voronoiLayer.addTo(map);
            circlesLayer.addTo(map);

            const fileInput = document.getElementById('csv-file');
            const sampleButton = document.getElementById('load-sample');
            const solarSlider = document.getElementById('solar-slider');
            const windSlider = document.getElementById('wind-slider');
            const batterySlider = document.getElementById('battery-slider');
            const lcoeSlider = document.getElementById('lcoe-slider');
            const solarValueLabel = document.getElementById('solar-value');
            const windValueLabel = document.getElementById('wind-value');
            const batteryValueLabel = document.getElementById('battery-value');
            const lcoeValueLabel = document.getElementById('lcoe-value');
            const statusMessage = document.getElementById('status-message');
            const slidersSection = document.getElementById('sliders-section');
            const modeMixRadio = document.getElementById('mode-mix');
            const modeLcoeRadio = document.getElementById('mode-lcoe');
            const mixSlidersSection = document.getElementById('mix-sliders-section');
            const lcoeSliderSection = document.getElementById('lcoe-slider-section');

            function parseCSV(text) {
                const lines = text.trim().split(/\r?\n/);
                if (lines.length < 2) return [];
                const header = lines[0].split(',').map((h) => h.trim());
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i]) continue;
                    const values = lines[i].split(',');
                    if (values.length !== header.length) continue;
                    const entry = {};
                    for (let j = 0; j < header.length; j++) {
                        const raw = values[j].trim();
                        const numValue = parseFloat(raw);
                        entry[header[j]] = raw === '' || Number.isNaN(numValue) ? raw : numValue;
                    }
                    data.push(entry);
                }
                return data;
            }

            function finalizeDataLoad(filename, rowCount) {
                if (rowCount === 0) {
                    statusMessage.textContent = 'File parsed but no rows were detected.';
                    return;
                }
                availableWindLevels = new Set(dispatchData.map((row) => Number(row.Wind_GW ?? 0)));
                slidersSection.classList.remove('hidden');
                statusMessage.textContent = `Loaded ${rowCount} rows from ${filename}.`;
                updateMap();
                addLegend();
            }

            async function loadSampleData() {
                try {
                    statusMessage.textContent = 'Downloading sample data...';
                    const response = await fetch('sample_dashboard_data.csv');
                    if (!response.ok) throw new Error('Sample file missing.');
                    const text = await response.text();
                    dispatchData = parseCSV(text);
                    finalizeDataLoad('sample_dashboard_data.csv', dispatchData.length);
                } catch (err) {
                    console.error(err);
                    statusMessage.textContent = `Failed to load sample data: ${err.message}`;
                }
            }

            sampleButton.addEventListener('click', loadSampleData);

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                statusMessage.textContent = `Loading ${file.name}...`;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const text = e.target.result;
                        dispatchData = parseCSV(text);
                        finalizeDataLoad(file.name, dispatchData.length);
                    } catch (err) {
                        statusMessage.textContent = `Error processing file: ${err.message}`;
                    }
                };
                reader.readAsText(file);
            });

            modeMixRadio.addEventListener('change', () => {
                mixSlidersSection.classList.remove('hidden');
                lcoeSliderSection.classList.add('hidden');
                updateMap();
            });
            modeLcoeRadio.addEventListener('change', () => {
                mixSlidersSection.classList.add('hidden');
                lcoeSliderSection.classList.remove('hidden');
                updateMap();
            });

            solarSlider.addEventListener('input', () => {
                solarValueLabel.textContent = `${solarSlider.value} GW`;
                updateMap();
            });
            windSlider.addEventListener('input', () => {
                windValueLabel.textContent = `${windSlider.value} GW`;
                updateMap();
            });
            batterySlider.addEventListener('input', () => {
                batteryValueLabel.textContent = `${batterySlider.value} GWh`;
                updateMap();
            });
            lcoeSlider.addEventListener('input', () => {
                lcoeValueLabel.textContent = `$${lcoeSlider.value} / MWh`;
                updateMap();
            });
            map.on('moveend', () => updateMap());

            function approxEqual(a, b, tolerance = 0.01) {
                return Math.abs(a - b) <= tolerance;
            }

            function nearestWindLevel(target) {
                if (availableWindLevels.size === 0) return target;
                let best = null;
                let bestDiff = Infinity;
                availableWindLevels.forEach((value) => {
                    const diff = Math.abs(value - target);
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        best = value;
                    }
                });
                return best;
            }

            function updateMap() {
                if (dispatchData.length === 0 || !map || !worldGeoJSON) return;
                circlesLayer.clearLayers();
                d3.select(voronoiLayer._container).selectAll('*').remove();
                let dataToDisplay = [];
                const currentMode = document.querySelector('input[name="vis-mode"]:checked').value;
                if (currentMode === 'mix') {
                    const selectedSolar = Number(solarSlider.value);
                    const desiredWind = Number(windSlider.value);
                    const selectedBattery = Number(batterySlider.value);
                    let status = `Solar ${selectedSolar} GW • Battery ${selectedBattery} GWh`;
                    let windToUse = desiredWind;
                    const nearestWind = nearestWindLevel(desiredWind);
                    if (nearestWind !== null && !approxEqual(nearestWind, desiredWind)) {
                        status += ` • displaying closest wind data (${nearestWind} GW available)`;
                        windToUse = nearestWind;
                    }
                    dataToDisplay = dispatchData.filter((row) => {
                        const solar = Number(row.Solar_GW ?? 0);
                        const wind = Number(row.Wind_GW ?? 0);
                        const battery = Number(row.Battery_GWh ?? 0);
                        return (
                            approxEqual(solar, selectedSolar) &&
                            approxEqual(battery, selectedBattery) &&
                            approxEqual(wind, windToUse)
                        );
                    });
                    statusMessage.textContent = `Displaying ${dataToDisplay.length} locations for the selected mix. ${status}`;
                } else {
                    const maxLcoe = Number(lcoeSlider.value);
                    const bestConfigs = new Map();
                    dispatchData.forEach((row) => {
                        const location = row.Location;
                        const lcoe = Number(row.LCOE_USD_per_MWh);
                        const cf = Number(row.System_Capacity_Factor ?? 0);
                        if (!Number.isFinite(lcoe) || lcoe > maxLcoe) return;
                        if (!bestConfigs.has(location) || cf > bestConfigs.get(location).System_Capacity_Factor) {
                            bestConfigs.set(location, row);
                        }
                    });
                    dataToDisplay = Array.from(bestConfigs.values());
                    statusMessage.textContent = `Displaying ${dataToDisplay.length} locations that beat $${maxLcoe}/MWh.`;
                }
                const svg = d3.select(voronoiLayer._container);
                const mapPoints = [];
                const associatedData = [];
                dataToDisplay.forEach((row) => {
                    const coords = parseLocation(row.Location);
                    if (!coords) return;
                    const point = map.latLngToLayerPoint([coords.lat, coords.lon]);
                    mapPoints.push([point.x, point.y]);
                    associatedData.push({ row, coords });
                });
                const transform = d3.geoTransform({
                    point(x, y) {
                        const point = map.latLngToLayerPoint(new L.LatLng(y, x));
                        this.stream.point(point.x, point.y);
                    },
                });
                const path = d3.geoPath().projection(transform);
                svg.append('defs')
                    .append('clipPath')
                    .attr('id', 'clip-land')
                    .append('path')
                    .datum(worldGeoJSON)
                    .attr('d', path);
                if (mapPoints.length > 1) {
                    const delaunay = d3.Delaunay.from(mapPoints);
                    const mapSize = map.getSize();
                    const buffer = Math.max(mapSize.x, mapSize.y);
                    const bounds = [-buffer, -buffer, mapSize.x + buffer, mapSize.y + buffer];
                    const voronoi = delaunay.voronoi(bounds);
                    svg.append('g')
                        .attr('clip-path', 'url(#clip-land)')
                        .selectAll('path')
                        .data(mapPoints)
                        .enter()
                        .append('path')
                        .attr('d', (d, i) => voronoi.renderCell(i))
                        .attr('class', 'voronoi-cell')
                        .style('fill', (d, i) => getColorForCF(Number(associatedData[i].row.System_Capacity_Factor ?? 0)))
                        .style('fill-opacity', 0.6);
                } else if (mapPoints.length === 1) {
                    svg.append('g')
                        .attr('clip-path', 'url(#clip-land)')
                        .append('circle')
                        .attr('cx', mapPoints[0][0])
                        .attr('cy', mapPoints[0][1])
                        .attr('r', 10)
                        .attr('class', 'voronoi-cell')
                        .style('fill', getColorForCF(Number(associatedData[0].row.System_Capacity_Factor ?? 0)))
                        .style('fill-opacity', 0.6);
                }
                associatedData.forEach(({ row, coords }) => {
                    const color = getColorForCF(Number(row.System_Capacity_Factor ?? 0));
                    const circle = L.circleMarker([coords.lat, coords.lon], {
                        radius: 4,
                        weight: 0,
                        fillColor: color,
                        fillOpacity: 0.9,
                    }).addTo(circlesLayer);
                    const lcoeText = Number.isFinite(Number(row.LCOE_USD_per_MWh))
                        ? `$${Number(row.LCOE_USD_per_MWh).toFixed(2)}`
                        : 'N/A';
                    const tooltipContent = `
                        <div style="font-family: sans-serif; text-align: left;">
                            <strong>${row.Site_Name ?? 'Location'}</strong><br />
                            <span>${coords.lat.toFixed(2)}, ${coords.lon.toFixed(2)}</span>
                            <hr style="margin: 6px 0; border-color: #4b5563;" />
                            <strong>System CF:</strong> ${(Number(row.System_Capacity_Factor ?? 0) * 100).toFixed(2)}%<br />
                            <strong>LCOE:</strong> ${lcoeText}<br />
                            <strong>Mix:</strong> ${row.Solar_GW ?? '?'} GW solar, ${row.Wind_GW ?? '?'} GW wind, ${row.Battery_GWh ?? '?'} GWh battery
                        </div>`;
                    circle.bindTooltip(tooltipContent);
                });
            }

            function parseLocation(locationString) {
                if (typeof locationString !== 'string') return null;
                const parts = locationString.split('_');
                if (parts.length !== 2) return null;
                const lat = parseFloat(parts[0].replace('Lat', ''));
                const lon = parseFloat(parts[1].replace('Lon', ''));
                if (Number.isNaN(lat) || Number.isNaN(lon)) return null;
                return { lat, lon };
            }

            function getColorForCF(cf) {
                const clamped = Math.min(Math.max(cf || 0, 0), 1);
                const colors = [
                    { p: 0.0, color: { r: 0, g: 0, b: 255 } },
                    { p: 0.3, color: { r: 0, g: 255, b: 0 } },
                    { p: 0.65, color: { r: 255, g: 165, b: 0 } },
                    { p: 0.8, color: { r: 255, g: 0, b: 0 } },
                    { p: 1.0, color: { r: 139, g: 0, b: 0 } },
                ];
                if (clamped <= colors[0].p) return 'rgb(0,0,255)';
                if (clamped >= colors[colors.length - 1].p) return 'rgb(139,0,0)';
                let i = 1;
                while (i < colors.length && clamped > colors[i].p) {
                    i += 1;
                }
                const lower = colors[i - 1];
                const upper = colors[i];
                const scale = (clamped - lower.p) / (upper.p - lower.p);
                const r = Math.round(lower.color.r + scale * (upper.color.r - lower.color.r));
                const g = Math.round(lower.color.g + scale * (upper.color.g - lower.color.g));
                const b = Math.round(lower.color.b + scale * (upper.color.b - lower.color.b));
                return `rgb(${r},${g},${b})`;
            }

            function addLegend() {
                if (legend) map.removeControl(legend);
                legend = L.control({ position: 'bottomright' });
                legend.onAdd = function () {
                    const div = L.DomUtil.create('div', 'info legend');
                    div.classList.add('legend');
                    div.innerHTML = '<strong>System Capacity Factor</strong>';
                    const gradient = L.DomUtil.create('div', '', div);
                    const colors = [];
                    for (let i = 0; i <= 100; i++) {
                        colors.push(getColorForCF(i / 100));
                    }
                    gradient.style.height = '20px';
                    gradient.style.marginTop = '5px';
                    gradient.style.marginBottom = '5px';
                    gradient.style.width = '100%';
                    gradient.style.background = `linear-gradient(to right, ${colors.join(',')})`;
                    gradient.style.borderRadius = '3px';
                    const labels = L.DomUtil.create('div', 'legend-labels', div);
                    labels.innerHTML = '<span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>';
                    return div;
                };
                legend.addTo(map);
            }
        });
    </script>
</body>
</html>
